/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export type JBTokenAmountStruct = {
  token: string;
  value: BigNumberish;
  decimals: BigNumberish;
  currency: BigNumberish;
};

export type JBTokenAmountStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  token: string;
  value: BigNumber;
  decimals: BigNumber;
  currency: BigNumber;
};

export type JBDidPayDataStruct = {
  payer: string;
  projectId: BigNumberish;
  currentFundingCycleConfiguration: BigNumberish;
  amount: JBTokenAmountStruct;
  projectTokenCount: BigNumberish;
  beneficiary: string;
  preferClaimedTokens: boolean;
  memo: string;
  metadata: BytesLike;
};

export type JBDidPayDataStructOutput = [
  string,
  BigNumber,
  BigNumber,
  JBTokenAmountStructOutput,
  BigNumber,
  string,
  boolean,
  string,
  string
] & {
  payer: string;
  projectId: BigNumber;
  currentFundingCycleConfiguration: BigNumber;
  amount: JBTokenAmountStructOutput;
  projectTokenCount: BigNumber;
  beneficiary: string;
  preferClaimedTokens: boolean;
  memo: string;
  metadata: string;
};

export type JBDidRedeemDataStruct = {
  holder: string;
  projectId: BigNumberish;
  currentFundingCycleConfiguration: BigNumberish;
  projectTokenCount: BigNumberish;
  reclaimedAmount: JBTokenAmountStruct;
  beneficiary: string;
  memo: string;
  metadata: BytesLike;
};

export type JBDidRedeemDataStructOutput = [
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  JBTokenAmountStructOutput,
  string,
  string,
  string
] & {
  holder: string;
  projectId: BigNumber;
  currentFundingCycleConfiguration: BigNumber;
  projectTokenCount: BigNumber;
  reclaimedAmount: JBTokenAmountStructOutput;
  beneficiary: string;
  memo: string;
  metadata: string;
};

export type JBSplitStruct = {
  preferClaimed: boolean;
  preferAddToBalance: boolean;
  percent: BigNumberish;
  projectId: BigNumberish;
  beneficiary: string;
  lockedUntil: BigNumberish;
  allocator: string;
};

export type JBSplitStructOutput = [
  boolean,
  boolean,
  BigNumber,
  BigNumber,
  string,
  BigNumber,
  string
] & {
  preferClaimed: boolean;
  preferAddToBalance: boolean;
  percent: BigNumber;
  projectId: BigNumber;
  beneficiary: string;
  lockedUntil: BigNumber;
  allocator: string;
};

export type JBFeeStruct = {
  amount: BigNumberish;
  fee: BigNumberish;
  feeDiscount: BigNumberish;
  beneficiary: string;
};

export type JBFeeStructOutput = [BigNumber, number, number, string] & {
  amount: BigNumber;
  fee: number;
  feeDiscount: number;
  beneficiary: string;
};

export interface JBETHPaymentTerminalInterface extends utils.Interface {
  functions: {
    "acceptsToken(address,uint256)": FunctionFragment;
    "addToBalanceOf(uint256,uint256,address,string,bytes)": FunctionFragment;
    "baseWeightCurrency()": FunctionFragment;
    "currency()": FunctionFragment;
    "currencyForToken(address)": FunctionFragment;
    "currentEthOverflowOf(uint256)": FunctionFragment;
    "decimals()": FunctionFragment;
    "decimalsForToken(address)": FunctionFragment;
    "directory()": FunctionFragment;
    "distributePayoutsOf(uint256,uint256,uint256,address,uint256,string)": FunctionFragment;
    "fee()": FunctionFragment;
    "feeGauge()": FunctionFragment;
    "heldFeesOf(uint256)": FunctionFragment;
    "isFeelessAddress(address)": FunctionFragment;
    "migrate(uint256,address)": FunctionFragment;
    "operatorStore()": FunctionFragment;
    "owner()": FunctionFragment;
    "pay(uint256,uint256,address,address,uint256,bool,string,bytes)": FunctionFragment;
    "payoutSplitsGroup()": FunctionFragment;
    "prices()": FunctionFragment;
    "processFees(uint256)": FunctionFragment;
    "projects()": FunctionFragment;
    "redeemTokensOf(address,uint256,uint256,address,uint256,address,string,bytes)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setFee(uint256)": FunctionFragment;
    "setFeeGauge(address)": FunctionFragment;
    "setFeelessAddress(address,bool)": FunctionFragment;
    "splitsStore()": FunctionFragment;
    "store()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "token()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "useAllowanceOf(uint256,uint256,uint256,address,uint256,address,string)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "acceptsToken"
      | "addToBalanceOf"
      | "baseWeightCurrency"
      | "currency"
      | "currencyForToken"
      | "currentEthOverflowOf"
      | "decimals"
      | "decimalsForToken"
      | "directory"
      | "distributePayoutsOf"
      | "fee"
      | "feeGauge"
      | "heldFeesOf"
      | "isFeelessAddress"
      | "migrate"
      | "operatorStore"
      | "owner"
      | "pay"
      | "payoutSplitsGroup"
      | "prices"
      | "processFees"
      | "projects"
      | "redeemTokensOf"
      | "renounceOwnership"
      | "setFee"
      | "setFeeGauge"
      | "setFeelessAddress"
      | "splitsStore"
      | "store"
      | "supportsInterface"
      | "token"
      | "transferOwnership"
      | "useAllowanceOf"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "acceptsToken",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addToBalanceOf",
    values: [BigNumberish, BigNumberish, string, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "baseWeightCurrency",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "currency", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "currencyForToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "currentEthOverflowOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "decimalsForToken",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "directory", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "distributePayoutsOf",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(functionFragment: "fee", values?: undefined): string;
  encodeFunctionData(functionFragment: "feeGauge", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "heldFeesOf",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isFeelessAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "migrate",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "operatorStore",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pay",
    values: [
      BigNumberish,
      BigNumberish,
      string,
      string,
      BigNumberish,
      boolean,
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "payoutSplitsGroup",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "prices", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "processFees",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "projects", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "redeemTokensOf",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      string,
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "setFeeGauge", values: [string]): string;
  encodeFunctionData(
    functionFragment: "setFeelessAddress",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "splitsStore",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "store", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "token", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "useAllowanceOf",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      string,
      string
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "acceptsToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addToBalanceOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "baseWeightCurrency",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "currency", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "currencyForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentEthOverflowOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "decimalsForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "directory", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "distributePayoutsOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "fee", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "feeGauge", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "heldFeesOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isFeelessAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "migrate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "operatorStore",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pay", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "payoutSplitsGroup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "prices", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "processFees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "projects", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemTokensOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setFeeGauge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeelessAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "splitsStore",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "store", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "useAllowanceOf",
    data: BytesLike
  ): Result;

  events: {
    "AddToBalance(uint256,uint256,uint256,string,bytes,address)": EventFragment;
    "DelegateDidPay(address,tuple,address)": EventFragment;
    "DelegateDidRedeem(address,tuple,address)": EventFragment;
    "DistributePayouts(uint256,uint256,uint256,address,uint256,uint256,uint256,uint256,string,address)": EventFragment;
    "DistributeToPayoutSplit(uint256,uint256,uint256,tuple,uint256,address)": EventFragment;
    "HoldFee(uint256,uint256,uint256,uint256,address,address)": EventFragment;
    "Migrate(uint256,address,uint256,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Pay(uint256,uint256,uint256,address,address,uint256,uint256,string,bytes,address)": EventFragment;
    "ProcessFee(uint256,uint256,bool,address,address)": EventFragment;
    "RedeemTokens(uint256,uint256,uint256,address,address,uint256,uint256,string,bytes,address)": EventFragment;
    "RefundHeldFees(uint256,uint256,uint256,uint256,address)": EventFragment;
    "SetFee(uint256,address)": EventFragment;
    "SetFeeGauge(address,address)": EventFragment;
    "SetFeelessAddress(address,bool,address)": EventFragment;
    "UseAllowance(uint256,uint256,uint256,address,uint256,uint256,uint256,string,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AddToBalance"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DelegateDidPay"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DelegateDidRedeem"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DistributePayouts"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DistributeToPayoutSplit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Migrate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Pay"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProcessFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RedeemTokens"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RefundHeldFees"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetFeeGauge"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetFeelessAddress"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UseAllowance"): EventFragment;
}

export interface AddToBalanceEventObject {
  projectId: BigNumber;
  amount: BigNumber;
  refundedFees: BigNumber;
  memo: string;
  metadata: string;
  caller: string;
}
export type AddToBalanceEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, string, string, string],
  AddToBalanceEventObject
>;

export type AddToBalanceEventFilter = TypedEventFilter<AddToBalanceEvent>;

export interface DelegateDidPayEventObject {
  delegate: string;
  data: JBDidPayDataStructOutput;
  caller: string;
}
export type DelegateDidPayEvent = TypedEvent<
  [string, JBDidPayDataStructOutput, string],
  DelegateDidPayEventObject
>;

export type DelegateDidPayEventFilter = TypedEventFilter<DelegateDidPayEvent>;

export interface DelegateDidRedeemEventObject {
  delegate: string;
  data: JBDidRedeemDataStructOutput;
  caller: string;
}
export type DelegateDidRedeemEvent = TypedEvent<
  [string, JBDidRedeemDataStructOutput, string],
  DelegateDidRedeemEventObject
>;

export type DelegateDidRedeemEventFilter =
  TypedEventFilter<DelegateDidRedeemEvent>;

export interface DistributePayoutsEventObject {
  fundingCycleConfiguration: BigNumber;
  fundingCycleNumber: BigNumber;
  projectId: BigNumber;
  beneficiary: string;
  amount: BigNumber;
  distributedAmount: BigNumber;
  fee: BigNumber;
  beneficiaryDistributionAmount: BigNumber;
  memo: string;
  caller: string;
}
export type DistributePayoutsEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string
  ],
  DistributePayoutsEventObject
>;

export type DistributePayoutsEventFilter =
  TypedEventFilter<DistributePayoutsEvent>;

export interface DistributeToPayoutSplitEventObject {
  projectId: BigNumber;
  domain: BigNumber;
  group: BigNumber;
  split: JBSplitStructOutput;
  amount: BigNumber;
  caller: string;
}
export type DistributeToPayoutSplitEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, JBSplitStructOutput, BigNumber, string],
  DistributeToPayoutSplitEventObject
>;

export type DistributeToPayoutSplitEventFilter =
  TypedEventFilter<DistributeToPayoutSplitEvent>;

export interface HoldFeeEventObject {
  projectId: BigNumber;
  amount: BigNumber;
  fee: BigNumber;
  feeDiscount: BigNumber;
  beneficiary: string;
  caller: string;
}
export type HoldFeeEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, string, string],
  HoldFeeEventObject
>;

export type HoldFeeEventFilter = TypedEventFilter<HoldFeeEvent>;

export interface MigrateEventObject {
  projectId: BigNumber;
  to: string;
  amount: BigNumber;
  caller: string;
}
export type MigrateEvent = TypedEvent<
  [BigNumber, string, BigNumber, string],
  MigrateEventObject
>;

export type MigrateEventFilter = TypedEventFilter<MigrateEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface PayEventObject {
  fundingCycleConfiguration: BigNumber;
  fundingCycleNumber: BigNumber;
  projectId: BigNumber;
  payer: string;
  beneficiary: string;
  amount: BigNumber;
  beneficiaryTokenCount: BigNumber;
  memo: string;
  metadata: string;
  caller: string;
}
export type PayEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    string,
    string
  ],
  PayEventObject
>;

export type PayEventFilter = TypedEventFilter<PayEvent>;

export interface ProcessFeeEventObject {
  projectId: BigNumber;
  amount: BigNumber;
  wasHeld: boolean;
  beneficiary: string;
  caller: string;
}
export type ProcessFeeEvent = TypedEvent<
  [BigNumber, BigNumber, boolean, string, string],
  ProcessFeeEventObject
>;

export type ProcessFeeEventFilter = TypedEventFilter<ProcessFeeEvent>;

export interface RedeemTokensEventObject {
  fundingCycleConfiguration: BigNumber;
  fundingCycleNumber: BigNumber;
  projectId: BigNumber;
  holder: string;
  beneficiary: string;
  tokenCount: BigNumber;
  reclaimedAmount: BigNumber;
  memo: string;
  metadata: string;
  caller: string;
}
export type RedeemTokensEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    string,
    string
  ],
  RedeemTokensEventObject
>;

export type RedeemTokensEventFilter = TypedEventFilter<RedeemTokensEvent>;

export interface RefundHeldFeesEventObject {
  projectId: BigNumber;
  amount: BigNumber;
  refundedFees: BigNumber;
  leftoverAmount: BigNumber;
  caller: string;
}
export type RefundHeldFeesEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, string],
  RefundHeldFeesEventObject
>;

export type RefundHeldFeesEventFilter = TypedEventFilter<RefundHeldFeesEvent>;

export interface SetFeeEventObject {
  fee: BigNumber;
  caller: string;
}
export type SetFeeEvent = TypedEvent<[BigNumber, string], SetFeeEventObject>;

export type SetFeeEventFilter = TypedEventFilter<SetFeeEvent>;

export interface SetFeeGaugeEventObject {
  feeGauge: string;
  caller: string;
}
export type SetFeeGaugeEvent = TypedEvent<
  [string, string],
  SetFeeGaugeEventObject
>;

export type SetFeeGaugeEventFilter = TypedEventFilter<SetFeeGaugeEvent>;

export interface SetFeelessAddressEventObject {
  addrs: string;
  flag: boolean;
  caller: string;
}
export type SetFeelessAddressEvent = TypedEvent<
  [string, boolean, string],
  SetFeelessAddressEventObject
>;

export type SetFeelessAddressEventFilter =
  TypedEventFilter<SetFeelessAddressEvent>;

export interface UseAllowanceEventObject {
  fundingCycleConfiguration: BigNumber;
  fundingCycleNumber: BigNumber;
  projectId: BigNumber;
  beneficiary: string;
  amount: BigNumber;
  distributedAmount: BigNumber;
  netDistributedamount: BigNumber;
  memo: string;
  caller: string;
}
export type UseAllowanceEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string
  ],
  UseAllowanceEventObject
>;

export type UseAllowanceEventFilter = TypedEventFilter<UseAllowanceEvent>;

export interface JBETHPaymentTerminal extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: JBETHPaymentTerminalInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * A flag indicating if this terminal accepts the specified token.
     * @param _projectId The project ID to check for token acceptance.
     * @param _token The token to check if this terminal accepts or not.
     */
    acceptsToken(
      _token: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Receives funds belonging to the specified project.
     * @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Extra data to pass along to the emitted event.
     * @param _projectId The ID of the project to which the funds received belong.
     * @param _token The token being paid. This terminal ignores this property since it only manages one currency.
     */
    addToBalanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The currency to base token issuance on.
     */
    baseWeightCurrency(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The currency to use when resolving price feeds for this terminal.
     */
    currency(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The currency that should be used for the specified token.
     * @param _token The token to check for the currency of.
     */
    currencyForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The current overflow is represented as a fixed point number with 18 decimals.
     * Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.
     * @param _projectId The ID of the project to get overflow for.
     */
    currentEthOverflowOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The number of decimals the token fixed point amounts are expected to have.
     */
    decimals(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The decimals that should be used in fixed number accounting for the specified token.
     * @param _token The token to check for the decimals of.
     */
    decimalsForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
     * Distributes payouts for a project with the distribution limit of its current funding cycle.
     * @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
     * @param _projectId The ID of the project having its payouts distributed.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    distributePayoutsOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _memo: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The platform fee percent.
     */
    fee(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The data source that returns a discount to apply to a project's fee.
     */
    feeGauge(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The fees that are currently being held to be processed later for each project.
     * @param _projectId The ID of the project for which fees are being held.
     */
    heldFeesOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[JBFeeStructOutput[]]>;

    /**
     * Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.
     */
    isFeelessAddress(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Only a project's owner or a designated operator can migrate it.
     * Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.
     * @param _projectId The ID of the project being migrated.
     * @param _to The terminal contract that will gain the project's funds.
     */
    migrate(
      _projectId: BigNumberish,
      _to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     *  A contract storing operator assignments.
     */
    operatorStore(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Contribute tokens to a project.
     * @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
     * @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
     * @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
     * @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
     * @param _projectId The ID of the project being paid.
     * @param _token The token being paid. This terminal ignores this property since it only manages one token.
     */
    pay(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _beneficiary: string,
      _minReturnedTokens: BigNumberish,
      _preferClaimedTokens: boolean,
      _memo: string,
      _metadata: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The group that payout splits coming from this terminal are identified by.
     */
    payoutSplitsGroup(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Only a project owner, an operator, or the contract's owner can process held fees.
     * Process any fees that are being held for the project.
     * @param _projectId The ID of the project whos held fees should be processed.
     */
    processFees(
      _projectId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Mints ERC-721's that represent project ownership and transfers.
     */
    projects(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Only a token holder or a designated operator can redeem its tokens.
     * Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
     * @param _beneficiary The address to send the terminal tokens to.
     * @param _holder The account to redeem tokens for.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    redeemTokensOf(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only the owner of this contract can change the fee.
     * Allows the fee to be updated.
     * @param _fee The new fee, out of MAX_FEE.
     */
    setFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only the owner of this contract can change the fee gauge.If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.
     * Allows the fee gauge to be updated.
     * @param _feeGauge The new fee gauge.
     */
    setFeeGauge(
      _feeGauge: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only the owner of this contract can set addresses as feeless.
     * Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.
     * @param _address The address that can be paid towards while still bypassing fees.
     * @param _flag A flag indicating whether the terminal should be feeless or not.
     */
    setFeelessAddress(
      _address: string,
      _flag: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The contract that stores splits for each project.
     */
    splitsStore(overrides?: CallOverrides): Promise<[string]>;

    /**
     * The contract that stores and manages the terminal's data.
     */
    store(overrides?: CallOverrides): Promise<[string]>;

    /**
     *  See {IERC165-supportsInterface}.
     * Indicates if this contract adheres to the specified interface.
     * @param _interfaceId The ID of the interface to check for adherance to.
     */
    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * The token that this terminal accepts.
     */
    token(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only a project's owner or a designated operator can use its allowance.Incurs the protocol fee.
     * Allows a project to send funds from its overflow up to the preconfigured allowance.
     * @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
     * @param _beneficiary The address to send the funds to.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
     * @param _projectId The ID of the project to use the allowance of.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    useAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  /**
   * A flag indicating if this terminal accepts the specified token.
   * @param _projectId The project ID to check for token acceptance.
   * @param _token The token to check if this terminal accepts or not.
   */
  acceptsToken(
    _token: string,
    _projectId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Receives funds belonging to the specified project.
   * @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
   * @param _memo A memo to pass along to the emitted event.
   * @param _metadata Extra data to pass along to the emitted event.
   * @param _projectId The ID of the project to which the funds received belong.
   * @param _token The token being paid. This terminal ignores this property since it only manages one currency.
   */
  addToBalanceOf(
    _projectId: BigNumberish,
    _amount: BigNumberish,
    _token: string,
    _memo: string,
    _metadata: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The currency to base token issuance on.
   */
  baseWeightCurrency(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The currency to use when resolving price feeds for this terminal.
   */
  currency(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The currency that should be used for the specified token.
   * @param _token The token to check for the currency of.
   */
  currencyForToken(
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The current overflow is represented as a fixed point number with 18 decimals.
   * Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.
   * @param _projectId The ID of the project to get overflow for.
   */
  currentEthOverflowOf(
    _projectId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The number of decimals the token fixed point amounts are expected to have.
   */
  decimals(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The decimals that should be used in fixed number accounting for the specified token.
   * @param _token The token to check for the decimals of.
   */
  decimalsForToken(
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The directory of terminals and controllers for projects.
   */
  directory(overrides?: CallOverrides): Promise<string>;

  /**
   * Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
   * Distributes payouts for a project with the distribution limit of its current funding cycle.
   * @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
   * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
   * @param _memo A memo to pass along to the emitted event.
   * @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
   * @param _projectId The ID of the project having its payouts distributed.
   * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
   */
  distributePayoutsOf(
    _projectId: BigNumberish,
    _amount: BigNumberish,
    _currency: BigNumberish,
    _token: string,
    _minReturnedTokens: BigNumberish,
    _memo: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The platform fee percent.
   */
  fee(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The data source that returns a discount to apply to a project's fee.
   */
  feeGauge(overrides?: CallOverrides): Promise<string>;

  /**
   * The fees that are currently being held to be processed later for each project.
   * @param _projectId The ID of the project for which fees are being held.
   */
  heldFeesOf(
    _projectId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<JBFeeStructOutput[]>;

  /**
   * Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.
   */
  isFeelessAddress(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Only a project's owner or a designated operator can migrate it.
   * Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.
   * @param _projectId The ID of the project being migrated.
   * @param _to The terminal contract that will gain the project's funds.
   */
  migrate(
    _projectId: BigNumberish,
    _to: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   *  A contract storing operator assignments.
   */
  operatorStore(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Contribute tokens to a project.
   * @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
   * @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
   * @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
   * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
   * @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
   * @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
   * @param _projectId The ID of the project being paid.
   * @param _token The token being paid. This terminal ignores this property since it only manages one token.
   */
  pay(
    _projectId: BigNumberish,
    _amount: BigNumberish,
    _token: string,
    _beneficiary: string,
    _minReturnedTokens: BigNumberish,
    _preferClaimedTokens: boolean,
    _memo: string,
    _metadata: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The group that payout splits coming from this terminal are identified by.
   */
  payoutSplitsGroup(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * The contract that exposes price feeds.
   */
  prices(overrides?: CallOverrides): Promise<string>;

  /**
   * Only a project owner, an operator, or the contract's owner can process held fees.
   * Process any fees that are being held for the project.
   * @param _projectId The ID of the project whos held fees should be processed.
   */
  processFees(
    _projectId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Mints ERC-721's that represent project ownership and transfers.
   */
  projects(overrides?: CallOverrides): Promise<string>;

  /**
   * Only a token holder or a designated operator can redeem its tokens.
   * Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
   * @param _beneficiary The address to send the terminal tokens to.
   * @param _holder The account to redeem tokens for.
   * @param _memo A memo to pass along to the emitted event.
   * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
   * @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
   * @param _projectId The ID of the project to which the tokens being redeemed belong.
   * @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.
   * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
   */
  redeemTokensOf(
    _holder: string,
    _projectId: BigNumberish,
    _tokenCount: BigNumberish,
    _token: string,
    _minReturnedTokens: BigNumberish,
    _beneficiary: string,
    _memo: string,
    _metadata: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only the owner of this contract can change the fee.
   * Allows the fee to be updated.
   * @param _fee The new fee, out of MAX_FEE.
   */
  setFee(
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only the owner of this contract can change the fee gauge.If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.
   * Allows the fee gauge to be updated.
   * @param _feeGauge The new fee gauge.
   */
  setFeeGauge(
    _feeGauge: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only the owner of this contract can set addresses as feeless.
   * Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.
   * @param _address The address that can be paid towards while still bypassing fees.
   * @param _flag A flag indicating whether the terminal should be feeless or not.
   */
  setFeelessAddress(
    _address: string,
    _flag: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The contract that stores splits for each project.
   */
  splitsStore(overrides?: CallOverrides): Promise<string>;

  /**
   * The contract that stores and manages the terminal's data.
   */
  store(overrides?: CallOverrides): Promise<string>;

  /**
   *  See {IERC165-supportsInterface}.
   * Indicates if this contract adheres to the specified interface.
   * @param _interfaceId The ID of the interface to check for adherance to.
   */
  supportsInterface(
    _interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * The token that this terminal accepts.
   */
  token(overrides?: CallOverrides): Promise<string>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only a project's owner or a designated operator can use its allowance.Incurs the protocol fee.
   * Allows a project to send funds from its overflow up to the preconfigured allowance.
   * @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
   * @param _beneficiary The address to send the funds to.
   * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
   * @param _memo A memo to pass along to the emitted event.
   * @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
   * @param _projectId The ID of the project to use the allowance of.
   * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
   */
  useAllowanceOf(
    _projectId: BigNumberish,
    _amount: BigNumberish,
    _currency: BigNumberish,
    _token: string,
    _minReturnedTokens: BigNumberish,
    _beneficiary: string,
    _memo: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    /**
     * A flag indicating if this terminal accepts the specified token.
     * @param _projectId The project ID to check for token acceptance.
     * @param _token The token to check if this terminal accepts or not.
     */
    acceptsToken(
      _token: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Receives funds belonging to the specified project.
     * @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Extra data to pass along to the emitted event.
     * @param _projectId The ID of the project to which the funds received belong.
     * @param _token The token being paid. This terminal ignores this property since it only manages one currency.
     */
    addToBalanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The currency to base token issuance on.
     */
    baseWeightCurrency(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The currency to use when resolving price feeds for this terminal.
     */
    currency(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The currency that should be used for the specified token.
     * @param _token The token to check for the currency of.
     */
    currencyForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The current overflow is represented as a fixed point number with 18 decimals.
     * Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.
     * @param _projectId The ID of the project to get overflow for.
     */
    currentEthOverflowOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The number of decimals the token fixed point amounts are expected to have.
     */
    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The decimals that should be used in fixed number accounting for the specified token.
     * @param _token The token to check for the decimals of.
     */
    decimalsForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<string>;

    /**
     * Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
     * Distributes payouts for a project with the distribution limit of its current funding cycle.
     * @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
     * @param _projectId The ID of the project having its payouts distributed.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    distributePayoutsOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _memo: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The platform fee percent.
     */
    fee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The data source that returns a discount to apply to a project's fee.
     */
    feeGauge(overrides?: CallOverrides): Promise<string>;

    /**
     * The fees that are currently being held to be processed later for each project.
     * @param _projectId The ID of the project for which fees are being held.
     */
    heldFeesOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<JBFeeStructOutput[]>;

    /**
     * Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.
     */
    isFeelessAddress(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Only a project's owner or a designated operator can migrate it.
     * Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.
     * @param _projectId The ID of the project being migrated.
     * @param _to The terminal contract that will gain the project's funds.
     */
    migrate(
      _projectId: BigNumberish,
      _to: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     *  A contract storing operator assignments.
     */
    operatorStore(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Contribute tokens to a project.
     * @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
     * @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
     * @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
     * @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
     * @param _projectId The ID of the project being paid.
     * @param _token The token being paid. This terminal ignores this property since it only manages one token.
     */
    pay(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _beneficiary: string,
      _minReturnedTokens: BigNumberish,
      _preferClaimedTokens: boolean,
      _memo: string,
      _metadata: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The group that payout splits coming from this terminal are identified by.
     */
    payoutSplitsGroup(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<string>;

    /**
     * Only a project owner, an operator, or the contract's owner can process held fees.
     * Process any fees that are being held for the project.
     * @param _projectId The ID of the project whos held fees should be processed.
     */
    processFees(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mints ERC-721's that represent project ownership and transfers.
     */
    projects(overrides?: CallOverrides): Promise<string>;

    /**
     * Only a token holder or a designated operator can redeem its tokens.
     * Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
     * @param _beneficiary The address to send the terminal tokens to.
     * @param _holder The account to redeem tokens for.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    redeemTokensOf(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Only the owner of this contract can change the fee.
     * Allows the fee to be updated.
     * @param _fee The new fee, out of MAX_FEE.
     */
    setFee(_fee: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Only the owner of this contract can change the fee gauge.If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.
     * Allows the fee gauge to be updated.
     * @param _feeGauge The new fee gauge.
     */
    setFeeGauge(_feeGauge: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Only the owner of this contract can set addresses as feeless.
     * Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.
     * @param _address The address that can be paid towards while still bypassing fees.
     * @param _flag A flag indicating whether the terminal should be feeless or not.
     */
    setFeelessAddress(
      _address: string,
      _flag: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The contract that stores splits for each project.
     */
    splitsStore(overrides?: CallOverrides): Promise<string>;

    /**
     * The contract that stores and manages the terminal's data.
     */
    store(overrides?: CallOverrides): Promise<string>;

    /**
     *  See {IERC165-supportsInterface}.
     * Indicates if this contract adheres to the specified interface.
     * @param _interfaceId The ID of the interface to check for adherance to.
     */
    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * The token that this terminal accepts.
     */
    token(overrides?: CallOverrides): Promise<string>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only a project's owner or a designated operator can use its allowance.Incurs the protocol fee.
     * Allows a project to send funds from its overflow up to the preconfigured allowance.
     * @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
     * @param _beneficiary The address to send the funds to.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
     * @param _projectId The ID of the project to use the allowance of.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    useAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "AddToBalance(uint256,uint256,uint256,string,bytes,address)"(
      projectId?: BigNumberish | null,
      amount?: null,
      refundedFees?: null,
      memo?: null,
      metadata?: null,
      caller?: null
    ): AddToBalanceEventFilter;
    AddToBalance(
      projectId?: BigNumberish | null,
      amount?: null,
      refundedFees?: null,
      memo?: null,
      metadata?: null,
      caller?: null
    ): AddToBalanceEventFilter;

    "DelegateDidPay(address,tuple,address)"(
      delegate?: string | null,
      data?: null,
      caller?: null
    ): DelegateDidPayEventFilter;
    DelegateDidPay(
      delegate?: string | null,
      data?: null,
      caller?: null
    ): DelegateDidPayEventFilter;

    "DelegateDidRedeem(address,tuple,address)"(
      delegate?: string | null,
      data?: null,
      caller?: null
    ): DelegateDidRedeemEventFilter;
    DelegateDidRedeem(
      delegate?: string | null,
      data?: null,
      caller?: null
    ): DelegateDidRedeemEventFilter;

    "DistributePayouts(uint256,uint256,uint256,address,uint256,uint256,uint256,uint256,string,address)"(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      beneficiary?: null,
      amount?: null,
      distributedAmount?: null,
      fee?: null,
      beneficiaryDistributionAmount?: null,
      memo?: null,
      caller?: null
    ): DistributePayoutsEventFilter;
    DistributePayouts(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      beneficiary?: null,
      amount?: null,
      distributedAmount?: null,
      fee?: null,
      beneficiaryDistributionAmount?: null,
      memo?: null,
      caller?: null
    ): DistributePayoutsEventFilter;

    "DistributeToPayoutSplit(uint256,uint256,uint256,tuple,uint256,address)"(
      projectId?: BigNumberish | null,
      domain?: BigNumberish | null,
      group?: BigNumberish | null,
      split?: null,
      amount?: null,
      caller?: null
    ): DistributeToPayoutSplitEventFilter;
    DistributeToPayoutSplit(
      projectId?: BigNumberish | null,
      domain?: BigNumberish | null,
      group?: BigNumberish | null,
      split?: null,
      amount?: null,
      caller?: null
    ): DistributeToPayoutSplitEventFilter;

    "HoldFee(uint256,uint256,uint256,uint256,address,address)"(
      projectId?: BigNumberish | null,
      amount?: BigNumberish | null,
      fee?: BigNumberish | null,
      feeDiscount?: null,
      beneficiary?: null,
      caller?: null
    ): HoldFeeEventFilter;
    HoldFee(
      projectId?: BigNumberish | null,
      amount?: BigNumberish | null,
      fee?: BigNumberish | null,
      feeDiscount?: null,
      beneficiary?: null,
      caller?: null
    ): HoldFeeEventFilter;

    "Migrate(uint256,address,uint256,address)"(
      projectId?: BigNumberish | null,
      to?: string | null,
      amount?: null,
      caller?: null
    ): MigrateEventFilter;
    Migrate(
      projectId?: BigNumberish | null,
      to?: string | null,
      amount?: null,
      caller?: null
    ): MigrateEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "Pay(uint256,uint256,uint256,address,address,uint256,uint256,string,bytes,address)"(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      payer?: null,
      beneficiary?: null,
      amount?: null,
      beneficiaryTokenCount?: null,
      memo?: null,
      metadata?: null,
      caller?: null
    ): PayEventFilter;
    Pay(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      payer?: null,
      beneficiary?: null,
      amount?: null,
      beneficiaryTokenCount?: null,
      memo?: null,
      metadata?: null,
      caller?: null
    ): PayEventFilter;

    "ProcessFee(uint256,uint256,bool,address,address)"(
      projectId?: BigNumberish | null,
      amount?: BigNumberish | null,
      wasHeld?: boolean | null,
      beneficiary?: null,
      caller?: null
    ): ProcessFeeEventFilter;
    ProcessFee(
      projectId?: BigNumberish | null,
      amount?: BigNumberish | null,
      wasHeld?: boolean | null,
      beneficiary?: null,
      caller?: null
    ): ProcessFeeEventFilter;

    "RedeemTokens(uint256,uint256,uint256,address,address,uint256,uint256,string,bytes,address)"(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      holder?: null,
      beneficiary?: null,
      tokenCount?: null,
      reclaimedAmount?: null,
      memo?: null,
      metadata?: null,
      caller?: null
    ): RedeemTokensEventFilter;
    RedeemTokens(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      holder?: null,
      beneficiary?: null,
      tokenCount?: null,
      reclaimedAmount?: null,
      memo?: null,
      metadata?: null,
      caller?: null
    ): RedeemTokensEventFilter;

    "RefundHeldFees(uint256,uint256,uint256,uint256,address)"(
      projectId?: BigNumberish | null,
      amount?: BigNumberish | null,
      refundedFees?: BigNumberish | null,
      leftoverAmount?: null,
      caller?: null
    ): RefundHeldFeesEventFilter;
    RefundHeldFees(
      projectId?: BigNumberish | null,
      amount?: BigNumberish | null,
      refundedFees?: BigNumberish | null,
      leftoverAmount?: null,
      caller?: null
    ): RefundHeldFeesEventFilter;

    "SetFee(uint256,address)"(fee?: null, caller?: null): SetFeeEventFilter;
    SetFee(fee?: null, caller?: null): SetFeeEventFilter;

    "SetFeeGauge(address,address)"(
      feeGauge?: string | null,
      caller?: null
    ): SetFeeGaugeEventFilter;
    SetFeeGauge(
      feeGauge?: string | null,
      caller?: null
    ): SetFeeGaugeEventFilter;

    "SetFeelessAddress(address,bool,address)"(
      addrs?: string | null,
      flag?: boolean | null,
      caller?: null
    ): SetFeelessAddressEventFilter;
    SetFeelessAddress(
      addrs?: string | null,
      flag?: boolean | null,
      caller?: null
    ): SetFeelessAddressEventFilter;

    "UseAllowance(uint256,uint256,uint256,address,uint256,uint256,uint256,string,address)"(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      beneficiary?: null,
      amount?: null,
      distributedAmount?: null,
      netDistributedamount?: null,
      memo?: null,
      caller?: null
    ): UseAllowanceEventFilter;
    UseAllowance(
      fundingCycleConfiguration?: BigNumberish | null,
      fundingCycleNumber?: BigNumberish | null,
      projectId?: BigNumberish | null,
      beneficiary?: null,
      amount?: null,
      distributedAmount?: null,
      netDistributedamount?: null,
      memo?: null,
      caller?: null
    ): UseAllowanceEventFilter;
  };

  estimateGas: {
    /**
     * A flag indicating if this terminal accepts the specified token.
     * @param _projectId The project ID to check for token acceptance.
     * @param _token The token to check if this terminal accepts or not.
     */
    acceptsToken(
      _token: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Receives funds belonging to the specified project.
     * @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Extra data to pass along to the emitted event.
     * @param _projectId The ID of the project to which the funds received belong.
     * @param _token The token being paid. This terminal ignores this property since it only manages one currency.
     */
    addToBalanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The currency to base token issuance on.
     */
    baseWeightCurrency(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The currency to use when resolving price feeds for this terminal.
     */
    currency(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The currency that should be used for the specified token.
     * @param _token The token to check for the currency of.
     */
    currencyForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The current overflow is represented as a fixed point number with 18 decimals.
     * Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.
     * @param _projectId The ID of the project to get overflow for.
     */
    currentEthOverflowOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The number of decimals the token fixed point amounts are expected to have.
     */
    decimals(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The decimals that should be used in fixed number accounting for the specified token.
     * @param _token The token to check for the decimals of.
     */
    decimalsForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
     * Distributes payouts for a project with the distribution limit of its current funding cycle.
     * @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
     * @param _projectId The ID of the project having its payouts distributed.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    distributePayoutsOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _memo: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The platform fee percent.
     */
    fee(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The data source that returns a discount to apply to a project's fee.
     */
    feeGauge(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The fees that are currently being held to be processed later for each project.
     * @param _projectId The ID of the project for which fees are being held.
     */
    heldFeesOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.
     */
    isFeelessAddress(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Only a project's owner or a designated operator can migrate it.
     * Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.
     * @param _projectId The ID of the project being migrated.
     * @param _to The terminal contract that will gain the project's funds.
     */
    migrate(
      _projectId: BigNumberish,
      _to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     *  A contract storing operator assignments.
     */
    operatorStore(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Contribute tokens to a project.
     * @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
     * @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
     * @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
     * @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
     * @param _projectId The ID of the project being paid.
     * @param _token The token being paid. This terminal ignores this property since it only manages one token.
     */
    pay(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _beneficiary: string,
      _minReturnedTokens: BigNumberish,
      _preferClaimedTokens: boolean,
      _memo: string,
      _metadata: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The group that payout splits coming from this terminal are identified by.
     */
    payoutSplitsGroup(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Only a project owner, an operator, or the contract's owner can process held fees.
     * Process any fees that are being held for the project.
     * @param _projectId The ID of the project whos held fees should be processed.
     */
    processFees(
      _projectId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Mints ERC-721's that represent project ownership and transfers.
     */
    projects(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Only a token holder or a designated operator can redeem its tokens.
     * Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
     * @param _beneficiary The address to send the terminal tokens to.
     * @param _holder The account to redeem tokens for.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    redeemTokensOf(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only the owner of this contract can change the fee.
     * Allows the fee to be updated.
     * @param _fee The new fee, out of MAX_FEE.
     */
    setFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only the owner of this contract can change the fee gauge.If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.
     * Allows the fee gauge to be updated.
     * @param _feeGauge The new fee gauge.
     */
    setFeeGauge(
      _feeGauge: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only the owner of this contract can set addresses as feeless.
     * Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.
     * @param _address The address that can be paid towards while still bypassing fees.
     * @param _flag A flag indicating whether the terminal should be feeless or not.
     */
    setFeelessAddress(
      _address: string,
      _flag: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The contract that stores splits for each project.
     */
    splitsStore(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The contract that stores and manages the terminal's data.
     */
    store(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     *  See {IERC165-supportsInterface}.
     * Indicates if this contract adheres to the specified interface.
     * @param _interfaceId The ID of the interface to check for adherance to.
     */
    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The token that this terminal accepts.
     */
    token(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only a project's owner or a designated operator can use its allowance.Incurs the protocol fee.
     * Allows a project to send funds from its overflow up to the preconfigured allowance.
     * @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
     * @param _beneficiary The address to send the funds to.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
     * @param _projectId The ID of the project to use the allowance of.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    useAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * A flag indicating if this terminal accepts the specified token.
     * @param _projectId The project ID to check for token acceptance.
     * @param _token The token to check if this terminal accepts or not.
     */
    acceptsToken(
      _token: string,
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Receives funds belonging to the specified project.
     * @param _amount The amount of tokens to add, as a fixed point number with the same number of decimals as this terminal. If this is an ETH terminal, this is ignored and msg.value is used instead.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Extra data to pass along to the emitted event.
     * @param _projectId The ID of the project to which the funds received belong.
     * @param _token The token being paid. This terminal ignores this property since it only manages one currency.
     */
    addToBalanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The currency to base token issuance on.
     */
    baseWeightCurrency(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The currency to use when resolving price feeds for this terminal.
     */
    currency(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The currency that should be used for the specified token.
     * @param _token The token to check for the currency of.
     */
    currencyForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The current overflow is represented as a fixed point number with 18 decimals.
     * Gets the current overflowed amount in this terminal for a specified project, in terms of ETH.
     * @param _projectId The ID of the project to get overflow for.
     */
    currentEthOverflowOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The number of decimals the token fixed point amounts are expected to have.
     */
    decimals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The decimals that should be used in fixed number accounting for the specified token.
     * @param _token The token to check for the decimals of.
     */
    decimalsForToken(
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The directory of terminals and controllers for projects.
     */
    directory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Payouts are sent to the preprogrammed splits. Any leftover is sent to the project's owner.Anyone can distribute payouts on a project's behalf. The project can preconfigure a wildcard split that is used to send funds to msg.sender. This can be used to incentivize calling this function.All funds distributed outside of this contract or any feeless terminals incure the protocol fee.
     * Distributes payouts for a project with the distribution limit of its current funding cycle.
     * @param _amount The amount of terminal tokens to distribute, as a fixed point number with same number of decimals as this terminal.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's distribution limit currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of terminal tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with the same number of decimals as this terminal.
     * @param _projectId The ID of the project having its payouts distributed.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    distributePayoutsOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _memo: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The platform fee percent.
     */
    fee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The data source that returns a discount to apply to a project's fee.
     */
    feeGauge(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The fees that are currently being held to be processed later for each project.
     * @param _projectId The ID of the project for which fees are being held.
     */
    heldFeesOf(
      _projectId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Addresses that can be paid towards from this terminal without incurring a fee. _address The address that can be paid toward.
     */
    isFeelessAddress(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Only a project's owner or a designated operator can migrate it.
     * Allows a project owner to migrate its funds and operations to a new terminal that accepts the same token type.
     * @param _projectId The ID of the project being migrated.
     * @param _to The terminal contract that will gain the project's funds.
     */
    migrate(
      _projectId: BigNumberish,
      _to: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     *  A contract storing operator assignments.
     */
    operatorStore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Contribute tokens to a project.
     * @param _amount The amount of terminal tokens being received, as a fixed point number with the same amount of decimals as this terminal. If this terminal's token is ETH, this is ignored and msg.value is used in its place.
     * @param _beneficiary The address to mint tokens for and pass along to the funding cycle's data source and delegate.
     * @param _memo A memo to pass along to the emitted event, and passed along the the funding cycle's data source and delegate.  A data source can alter the memo before emitting in the event and forwarding to the delegate.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum number of project tokens expected in return, as a fixed point number with the same amount of decimals as this terminal.
     * @param _preferClaimedTokens A flag indicating whether the request prefers to mint project tokens into the beneficiaries wallet rather than leaving them unclaimed. This is only possible if the project has an attached token contract. Leaving them unclaimed saves gas.
     * @param _projectId The ID of the project being paid.
     * @param _token The token being paid. This terminal ignores this property since it only manages one token.
     */
    pay(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      _beneficiary: string,
      _minReturnedTokens: BigNumberish,
      _preferClaimedTokens: boolean,
      _memo: string,
      _metadata: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The group that payout splits coming from this terminal are identified by.
     */
    payoutSplitsGroup(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The contract that exposes price feeds.
     */
    prices(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Only a project owner, an operator, or the contract's owner can process held fees.
     * Process any fees that are being held for the project.
     * @param _projectId The ID of the project whos held fees should be processed.
     */
    processFees(
      _projectId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Mints ERC-721's that represent project ownership and transfers.
     */
    projects(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Only a token holder or a designated operator can redeem its tokens.
     * Holders can redeem their tokens to claim the project's overflowed tokens, or to trigger rules determined by the project's current funding cycle's data source.
     * @param _beneficiary The address to send the terminal tokens to.
     * @param _holder The account to redeem tokens for.
     * @param _memo A memo to pass along to the emitted event.
     * @param _metadata Bytes to send along to the data source, delegate, and emitted event, if provided.
     * @param _minReturnedTokens The minimum amount of terminal tokens expected in return, as a fixed point number with the same amount of decimals as the terminal.
     * @param _projectId The ID of the project to which the tokens being redeemed belong.
     * @param _token The token being reclaimed. This terminal ignores this property since it only manages one token.
     * @param _tokenCount The number of project tokens to redeem, as a fixed point number with 18 decimals.
     */
    redeemTokensOf(
      _holder: string,
      _projectId: BigNumberish,
      _tokenCount: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      _metadata: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only the owner of this contract can change the fee.
     * Allows the fee to be updated.
     * @param _fee The new fee, out of MAX_FEE.
     */
    setFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only the owner of this contract can change the fee gauge.If the fee gauge reverts when called upon while a project is attempting to distribute its funds, a project's funds will be locked. This is a known risk.
     * Allows the fee gauge to be updated.
     * @param _feeGauge The new fee gauge.
     */
    setFeeGauge(
      _feeGauge: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only the owner of this contract can set addresses as feeless.
     * Sets whether projects operating on this terminal can pay towards the specified address without incurring a fee.
     * @param _address The address that can be paid towards while still bypassing fees.
     * @param _flag A flag indicating whether the terminal should be feeless or not.
     */
    setFeelessAddress(
      _address: string,
      _flag: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The contract that stores splits for each project.
     */
    splitsStore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The contract that stores and manages the terminal's data.
     */
    store(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     *  See {IERC165-supportsInterface}.
     * Indicates if this contract adheres to the specified interface.
     * @param _interfaceId The ID of the interface to check for adherance to.
     */
    supportsInterface(
      _interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The token that this terminal accepts.
     */
    token(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only a project's owner or a designated operator can use its allowance.Incurs the protocol fee.
     * Allows a project to send funds from its overflow up to the preconfigured allowance.
     * @param _amount The amount of terminal tokens to use from this project's current allowance, as a fixed point number with the same amount of decimals as this terminal.
     * @param _beneficiary The address to send the funds to.
     * @param _currency The expected currency of the amount being distributed. Must match the project's current funding cycle's overflow allowance currency.
     * @param _memo A memo to pass along to the emitted event.
     * @param _minReturnedTokens The minimum number of tokens that the `_amount` should be valued at in terms of this terminal's currency, as a fixed point number with 18 decimals.
     * @param _projectId The ID of the project to use the allowance of.
     * @param _token The token being distributed. This terminal ignores this property since it only manages one token.
     */
    useAllowanceOf(
      _projectId: BigNumberish,
      _amount: BigNumberish,
      _currency: BigNumberish,
      _token: string,
      _minReturnedTokens: BigNumberish,
      _beneficiary: string,
      _memo: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
